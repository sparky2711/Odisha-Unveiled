{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = componentWithName;\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _isRegex = _interopRequireDefault(require(\"is-regex\"));\nvar _arrayPrototype = _interopRequireDefault(require(\"array.prototype.find\"));\nvar _getComponentName = _interopRequireDefault(require(\"./helpers/getComponentName\"));\nvar _wrapValidator = _interopRequireDefault(require(\"./helpers/wrapValidator\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction stripHOCs(fullName, namesOfHOCsToStrip) {\n  var innerName = fullName;\n  while (/\\([^()]*\\)/g.test(innerName)) {\n    var HOC = innerName;\n    var previousHOC = void 0;\n    do {\n      previousHOC = HOC;\n      HOC = previousHOC.replace(/\\([^()]*\\)/g, '');\n    } while (previousHOC !== HOC);\n    if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n      return innerName;\n    }\n    innerName = innerName.replace(RegExp(\"^\".concat(HOC, \"\\\\(|\\\\)$\"), 'g'), '');\n  }\n  return innerName;\n}\nfunction hasName(name, namesOfHOCsToStrip, propValue, propName, componentName) {\n  for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n    rest[_key - 5] = arguments[_key];\n  }\n  if (Array.isArray(propValue)) {\n    return (0, _arrayPrototype[\"default\"])(propValue.map(function (item) {\n      return hasName.apply(void 0, [name, namesOfHOCsToStrip, item, propName, componentName].concat(rest));\n    }), Boolean) || null;\n  }\n  if (! /*#__PURE__*/_react[\"default\"].isValidElement(propValue)) {\n    return new TypeError(\"\".concat(componentName, \".\").concat(propName, \" is not a valid React element\"));\n  }\n  var type = propValue.type;\n  var componentNameFromType = (0, _getComponentName[\"default\"])(type);\n  var innerComponentName = namesOfHOCsToStrip.length > 0 ? stripHOCs(componentNameFromType, namesOfHOCsToStrip) : componentNameFromType;\n  if ((0, _isRegex[\"default\"])(name) && !name.test(innerComponentName)) {\n    return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` only accepts components matching the regular expression \").concat(name));\n  }\n  if (!(0, _isRegex[\"default\"])(name) && innerComponentName !== name) {\n    return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` only accepts components named \").concat(name, \", got \").concat(innerComponentName));\n  }\n  return null;\n}\nfunction componentWithName(name) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof name !== 'string' && !(0, _isRegex[\"default\"])(name)) {\n    throw new TypeError('name must be a string or a regex');\n  }\n  var passedOptions = Object.keys(options);\n  if (passedOptions.length > 1 || passedOptions.length === 1 && passedOptions[0] !== 'stripHOCs') {\n    throw new TypeError(\"The only options supported are: \\u201CstripHOCs\\u201D, got: \\u201C\".concat(passedOptions.join('”, “'), \"\\u201D\"));\n  }\n  var _options$stripHOCs = options.stripHOCs,\n    namesOfHOCsToStrip = _options$stripHOCs === void 0 ? [] : _options$stripHOCs;\n  var allHOCNamesAreValid = namesOfHOCsToStrip.every(function (x) {\n    if (typeof x !== 'string' || /[()]/g.test(x)) {\n      return false;\n    }\n    return /^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x);\n  });\n  if (!allHOCNamesAreValid) {\n    throw new TypeError('every provided HOC name must be a string with no parens, and in camelCase');\n  }\n  function componentWithNameValidator(props, propName, componentName) {\n    var propValue = props[propName];\n    if (props[propName] == null) {\n      return null;\n    }\n    for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      rest[_key2 - 3] = arguments[_key2];\n    }\n    return hasName.apply(void 0, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n  }\n  componentWithNameValidator.isRequired = function componentWithNameRequired(props, propName, componentName) {\n    var propValue = props[propName];\n    if (propValue == null) {\n      return new TypeError(\"`\".concat(componentName, \".\").concat(propName, \"` requires at least one component named \").concat(name));\n    }\n    for (var _len3 = arguments.length, rest = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      rest[_key3 - 3] = arguments[_key3];\n    }\n    return hasName.apply(void 0, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n  };\n  return (0, _wrapValidator[\"default\"])(componentWithNameValidator, \"componentWithName:\".concat(name), name);\n}","map":{"version":3,"names":["_react","_interopRequireDefault","require","_isRegex","_arrayPrototype","_getComponentName","_wrapValidator","stripHOCs","fullName","namesOfHOCsToStrip","innerName","test","HOC","previousHOC","replace","indexOf","RegExp","concat","hasName","name","propValue","propName","componentName","_len","arguments","length","rest","Array","_key","isArray","map","item","apply","Boolean","isValidElement","TypeError","type","componentNameFromType","innerComponentName","componentWithName","options","undefined","passedOptions","Object","keys","join","_options$stripHOCs","allHOCNamesAreValid","every","x","componentWithNameValidator","props","_len2","_key2","isRequired","componentWithNameRequired","_len3","_key3"],"sources":["C:\\Users\\animi\\Downloads\\React-projects-master\\React-projects-master\\Abodbnb\\node_modules\\airbnb-prop-types\\src\\componentWithName.js"],"sourcesContent":["import React from 'react';\nimport isRegex from 'is-regex';\nimport find from 'array.prototype.find';\n\nimport getComponentName from './helpers/getComponentName';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction stripHOCs(fullName, namesOfHOCsToStrip) {\n  let innerName = fullName;\n  while ((/\\([^()]*\\)/g).test(innerName)) {\n    let HOC = innerName;\n    let previousHOC;\n    do {\n      previousHOC = HOC;\n      HOC = previousHOC.replace(/\\([^()]*\\)/g, '');\n    } while (previousHOC !== HOC);\n\n    if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n      return innerName;\n    }\n    innerName = innerName.replace(RegExp(`^${HOC}\\\\(|\\\\)$`, 'g'), '');\n  }\n  return innerName;\n}\n\nfunction hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest) {\n  if (Array.isArray(propValue)) {\n    return find(\n      propValue.map((item) => hasName(\n        name,\n        namesOfHOCsToStrip,\n        item,\n        propName,\n        componentName,\n        ...rest,\n      )),\n      Boolean,\n    ) || null;\n  }\n\n  if (!React.isValidElement(propValue)) {\n    return new TypeError(\n      `${componentName}.${propName} is not a valid React element`,\n    );\n  }\n\n  const { type } = propValue;\n  const componentNameFromType = getComponentName(type);\n  const innerComponentName = namesOfHOCsToStrip.length > 0\n    ? stripHOCs(componentNameFromType, namesOfHOCsToStrip)\n    : componentNameFromType;\n\n  if (isRegex(name) && !name.test(innerComponentName)) {\n    return new TypeError(\n      `\\`${componentName}.${propName}\\` only accepts components matching the regular expression ${name}`,\n    );\n  }\n\n  if (!isRegex(name) && innerComponentName !== name) {\n    return new TypeError(\n      `\\`${componentName}.${propName}\\` only accepts components named ${name}, got ${innerComponentName}`,\n    );\n  }\n\n  return null;\n}\n\nexport default function componentWithName(\n  name,\n  options = {},\n) {\n  if (typeof name !== 'string' && !isRegex(name)) {\n    throw new TypeError('name must be a string or a regex');\n  }\n\n  const passedOptions = Object.keys(options);\n  if (passedOptions.length > 1 || (passedOptions.length === 1 && passedOptions[0] !== 'stripHOCs')) {\n    throw new TypeError(`The only options supported are: “stripHOCs”, got: “${passedOptions.join('”, “')}”`);\n  }\n  const { stripHOCs: namesOfHOCsToStrip = [] } = options;\n\n  const allHOCNamesAreValid = namesOfHOCsToStrip.every((x) => {\n    if (typeof x !== 'string' || /[()]/g.test(x)) {\n      return false;\n    }\n    return /^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x);\n  });\n  if (!allHOCNamesAreValid) {\n    throw new TypeError('every provided HOC name must be a string with no parens, and in camelCase');\n  }\n\n  function componentWithNameValidator(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n    if (props[propName] == null) {\n      return null;\n    }\n    return hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest);\n  }\n\n  componentWithNameValidator.isRequired = function componentWithNameRequired(\n    props,\n    propName,\n    componentName,\n    ...rest\n  ) {\n    const { [propName]: propValue } = props;\n    if (propValue == null) {\n      return new TypeError(`\\`${componentName}.${propName}\\` requires at least one component named ${name}`);\n    }\n    return hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(componentWithNameValidator, `componentWithName:${name}`, name);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}